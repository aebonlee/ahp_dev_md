# 화면 설계 분석 및 미개발 부분 개선

## 일시
- **일시**: 2025년 8월 17일 10:15:00

## 📊 요구사항 vs 현재 구현 비교

### 5.1 관리자 화면 분석

#### ✅ 구현 완료된 부분 (70%)

| 요구사항 단계 | 현재 구현 | 상태 | 파일 위치 |
|--------------|----------|------|-----------|
| **서비스 신청/로그인** | ✅ 완료 | 100% | `LoginForm.tsx` |
| **프로젝트 생성** | ✅ 완료 | 95% | `App.tsx` (프로젝트 관리) |
| **모델 구축 - 기준 추가** | ✅ 완료 | 90% | `ModelBuilder.tsx` |
| **모델 구축 - 대안 추가** | ✅ 완료 | 90% | `ModelBuilder.tsx` |
| **모델 확정/평가 시작** | ⚠️ 부분 | 30% | 상태 변경 로직 부족 |

#### ❌ 미구현 부분 (0-30%)

| 요구사항 단계 | 현재 상태 | 완성도 | 우선순위 |
|--------------|----------|--------|----------|
| **평가자 배정 (p001...)** | 미구현 | 0% | 🔥 높음 |
| **평가방법 선택** | 미구현 | 0% | 🔥 높음 |
| **결과/진행 현황** | 기초만 | 20% | 🔥 높음 |
| **그룹 가중치 조정** | 미구현 | 0% | 🔶 중간 |
| **민감도 분석** | 미구현 | 0% | 🔶 중간 |
| **자원배분 시뮬레이션** | 미구현 | 0% | 🔶 중간 |
| **워크숍 모드** | 미구현 | 0% | 🔹 낮음 |
| **내보내기 (Excel)** | 미구현 | 0% | 🔶 중간 |

### 5.2 평가자 화면 분석

#### ✅ 구현 완료된 부분 (50%)

| 요구사항 단계 | 현재 구현 | 상태 | 파일 위치 |
|--------------|----------|------|-----------|
| **접속키로 입장** | ⚠️ 부분 | 50% | 로그인만 있음 |
| **쌍대비교 UI** | ✅ 기본 | 70% | `PairwiseComparison.tsx` |
| **1~9/역수 버튼** | ✅ 완료 | 95% | Saaty 척도 구현 |
| **매트릭스 표시** | ✅ 완료 | 90% | 비교 매트릭스 테이블 |

#### ❌ 미구현 부분 (0-50%)

| 요구사항 단계 | 현재 상태 | 완성도 | 우선순위 |
|--------------|----------|--------|----------|
| **접속키 시스템** | 미구현 | 0% | 🔥 높음 |
| **배정된 프로젝트 선택** | 미구현 | 0% | 🔥 높음 |
| **직접입력 평가** | 미구현 | 0% | 🔥 높음 |
| **CR > 0.1 판단 도우미** | 미구현 | 0% | 🔥 높음 |
| **매트릭스 단위 "다음"** | 부분 | 30% | 🔶 중간 |
| **결과 확인 → Excel** | 미구현 | 0% | 🔶 중간 |
| **재평가 기능** | 미구현 | 0% | 🔶 중간 |

## 🚧 즉시 구현 필요한 컴포넌트

### 1. 평가자 배정 시스템 (EvaluatorAssignment.tsx)

```typescript
interface EvaluatorAssignmentProps {
  projectId: string;
  onComplete?: () => void;
}

interface Evaluator {
  id: string;
  code: string;      // p001, p002, ...
  name?: string;
  email?: string;
  isAssigned: boolean;
  weight: number;    // 그룹 가중치
}
```

### 2. 평가방법 선택 (EvaluationMethodSelector.tsx)

```typescript
interface EvaluationMethod {
  type: 'pairwise' | 'direct';
  criteria: string[];  // 해당 평가 방법을 사용할 기준 ID들
}

interface EvaluationMethodSelectorProps {
  projectId: string;
  criteria: Criterion[];
  onMethodChange: (methods: EvaluationMethod[]) => void;
}
```

### 3. 직접입력 평가 (DirectInputEvaluation.tsx)

```typescript
interface DirectInputProps {
  projectId: string;
  criterionId: string;
  alternatives: Alternative[];
  onComplete?: () => void;
}

interface DirectInputValue {
  alternativeId: string;
  value: number;
  isBenefit: boolean;  // 비용형 "역수 적용" 토글
}
```

### 4. 판단 도우미 (ConsistencyHelper.tsx)

```typescript
interface InconsistencyAdvice {
  i: number;
  j: number;
  currentValue: number;
  recommendedValue: number;
  errorMagnitude: number;
  rank: number;  // 제안 1, 2, 3
}

interface ConsistencyHelperProps {
  matrix: number[][];
  elements: (Criterion | Alternative)[];
  onSuggestionApply: (i: number, j: number, value: number) => void;
}
```

### 5. 진행 상황 대시보드 (ProgressDashboard.tsx)

```typescript
interface EvaluatorProgress {
  evaluatorId: string;
  evaluatorName: string;
  completionRate: number;    // 0-100%
  completedComparisons: number;
  totalComparisons: number;
  lastUpdated: Date;
}

interface ProgressDashboardProps {
  projectId: string;
  evaluators: EvaluatorProgress[];
}
```

### 6. 접속키 시스템 (AccessKeyLogin.tsx)

```typescript
interface AccessKeyLoginProps {
  onLogin: (evaluatorId: string, projectId: string) => void;
}

// 평가자는 이메일/패스워드 대신 접속키로 로그인
// 예: "P001-PROJ123" 형태
```

## 📝 개선이 필요한 기존 컴포넌트

### 1. ModelBuilder.tsx 개선

```typescript
// 추가 필요 기능
interface ModelBuilderState {
  evaluationMethods: { [criterionId: string]: 'pairwise' | 'direct' };
  projectStatus: 'draft' | 'ready' | 'running' | 'completed';
  assignedEvaluators: Evaluator[];
}

// 추가 필요 UI
- 평가방법 선택 드롭다운 (기준별)
- 평가자 배정 버튼
- 모델 확정 버튼 ("평가 시작")
- 상태 표시 배지
```

### 2. PairwiseComparison.tsx 개선

```typescript
// 추가 필요 기능
interface PairwiseComparisonState {
  currentMatrixKey: string;  // "C:criterionId" or "A:criterionId"
  matrixIndex: number;       // 현재 매트릭스 번호
  totalMatrices: number;     // 전체 매트릭스 수
  consistencyRatio: number;  // 실시간 CR 계산
  showConsistencyHelper: boolean;
}

// 추가 필요 UI
- 매트릭스 단위 네비게이션 ("이전 매트릭스", "다음 매트릭스")
- 실시간 일관성 표시
- CR > 0.1 시 "판단 도우미" 패널
- 매트릭스별 진행률 표시
```

### 3. ResultsDashboard.tsx 개선

```typescript
// 추가 필요 기능
interface ResultsDashboardState {
  viewMode: 'individual' | 'group';
  selectedEvaluators: string[];
  sensitivityAnalysis: SensitivityResult[];
  exportOptions: ExportConfig;
}

// 추가 필요 UI
- 개인/그룹 결과 토글
- 평가자 선택 체크박스
- 민감도 분석 차트
- Excel/CSV 내보내기 버튼
- 자원배분 시뮬레이션 패널
```

## 🔧 신규 컴포넌트 구현

### 1. 평가자 배정 컴포넌트

```typescript
// frontend/src/components/admin/EvaluatorAssignment.tsx
import React, { useState, useEffect } from 'react';
import Card from '../common/Card';

interface Evaluator {
  id: string;
  code: string;
  name: string;
  email?: string;
  weight: number;
  isAssigned: boolean;
}

const EvaluatorAssignment: React.FC<{projectId: string}> = ({ projectId }) => {
  const [evaluators, setEvaluators] = useState<Evaluator[]>([]);
  const [newEvaluatorCode, setNewEvaluatorCode] = useState('');
  const [newEvaluatorName, setNewEvaluatorName] = useState('');

  const generateAccessKey = (evaluatorCode: string) => {
    return `${evaluatorCode}-${projectId.substring(0, 8).toUpperCase()}`;
  };

  const addEvaluator = async () => {
    // API 호출로 평가자 추가
    const newEvaluator: Evaluator = {
      id: Date.now().toString(),
      code: newEvaluatorCode,
      name: newEvaluatorName,
      weight: 1.0,
      isAssigned: true
    };
    
    setEvaluators([...evaluators, newEvaluator]);
    setNewEvaluatorCode('');
    setNewEvaluatorName('');
  };

  return (
    <Card title="평가자 배정">
      <div className="space-y-4">
        {/* 평가자 추가 폼 */}
        <div className="bg-gray-50 p-4 rounded-lg">
          <h5 className="font-medium mb-3">새 평가자 추가</h5>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            <input
              type="text"
              placeholder="평가자 코드 (예: P001)"
              value={newEvaluatorCode}
              onChange={(e) => setNewEvaluatorCode(e.target.value.toUpperCase())}
              className="px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            <input
              type="text"
              placeholder="평가자 이름"
              value={newEvaluatorName}
              onChange={(e) => setNewEvaluatorName(e.target.value)}
              className="px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            <button
              onClick={addEvaluator}
              className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
            >
              추가
            </button>
          </div>
        </div>

        {/* 평가자 목록 */}
        <div className="space-y-2">
          {evaluators.map(evaluator => (
            <div key={evaluator.id} className="flex items-center justify-between p-3 bg-white border border-gray-200 rounded-lg">
              <div className="flex items-center space-x-4">
                <span className="font-medium">{evaluator.code}</span>
                <span>{evaluator.name}</span>
                <span className="text-sm text-gray-500">
                  접속키: {generateAccessKey(evaluator.code)}
                </span>
              </div>
              <div className="flex items-center space-x-2">
                <input
                  type="number"
                  min="0.1"
                  max="10"
                  step="0.1"
                  value={evaluator.weight}
                  onChange={(e) => {
                    const newWeight = parseFloat(e.target.value);
                    setEvaluators(evaluators.map(e => 
                      e.id === evaluator.id ? {...e, weight: newWeight} : e
                    ));
                  }}
                  className="w-16 px-2 py-1 border border-gray-300 rounded text-sm"
                />
                <span className="text-xs text-gray-500">가중치</span>
                <button
                  onClick={() => setEvaluators(evaluators.filter(e => e.id !== evaluator.id))}
                  className="text-red-500 hover:text-red-700"
                >
                  삭제
                </button>
              </div>
            </div>
          ))}
        </div>

        {evaluators.length === 0 && (
          <div className="text-center py-8 text-gray-500">
            배정된 평가자가 없습니다. 평가자를 추가해주세요.
          </div>
        )}
      </div>
    </Card>
  );
};

export default EvaluatorAssignment;
```

### 2. 직접입력 평가 컴포넌트

```typescript
// frontend/src/components/evaluation/DirectInputEvaluation.tsx
import React, { useState } from 'react';
import Card from '../common/Card';

interface DirectInputValue {
  alternativeId: string;
  alternativeName: string;
  value: number;
  isBenefit: boolean;
}

const DirectInputEvaluation: React.FC<{
  criterionId: string;
  criterionName: string;
  alternatives: Alternative[];
  onComplete: (values: DirectInputValue[]) => void;
}> = ({ criterionId, criterionName, alternatives, onComplete }) => {
  
  const [values, setValues] = useState<DirectInputValue[]>(
    alternatives.map(alt => ({
      alternativeId: alt.id,
      alternativeName: alt.name,
      value: 1,
      isBenefit: true
    }))
  );

  const [isBenefitCriterion, setIsBenefitCriterion] = useState(true);

  const updateValue = (alternativeId: string, newValue: number) => {
    setValues(values.map(v => 
      v.alternativeId === alternativeId 
        ? {...v, value: newValue} 
        : v
    ));
  };

  const calculateNormalizedWeights = () => {
    const processedValues = values.map(v => ({
      ...v,
      processedValue: isBenefitCriterion ? v.value : 1 / v.value
    }));

    const sum = processedValues.reduce((acc, v) => acc + v.processedValue, 0);
    
    return processedValues.map(v => ({
      ...v,
      normalizedWeight: v.processedValue / sum
    }));
  };

  const normalizedResults = calculateNormalizedWeights();

  return (
    <Card title={`직접입력 평가: ${criterionName}`}>
      <div className="space-y-6">
        {/* 평가 유형 선택 */}
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
          <h5 className="font-medium text-blue-800 mb-3">평가 유형 선택</h5>
          <div className="flex items-center space-x-4">
            <label className="flex items-center">
              <input
                type="radio"
                checked={isBenefitCriterion}
                onChange={() => setIsBenefitCriterion(true)}
                className="mr-2"
              />
              <span>편익형 (값이 클수록 좋음)</span>
            </label>
            <label className="flex items-center">
              <input
                type="radio"
                checked={!isBenefitCriterion}
                onChange={() => setIsBenefitCriterion(false)}
                className="mr-2"
              />
              <span>비용형 (값이 작을수록 좋음)</span>
            </label>
          </div>
          <p className="text-sm text-blue-600 mt-2">
            {isBenefitCriterion 
              ? "💡 편익형: 성과, 품질, 만족도 등" 
              : "💡 비용형: 가격, 소요시간, 위험도 등 (자동으로 역수 처리됩니다)"
            }
          </p>
        </div>

        {/* 값 입력 */}
        <div className="space-y-3">
          <h5 className="font-medium">대안별 값 입력</h5>
          {values.map(value => (
            <div key={value.alternativeId} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
              <span className="font-medium">{value.alternativeName}</span>
              <div className="flex items-center space-x-3">
                <input
                  type="number"
                  min="0.001"
                  step="0.001"
                  value={value.value}
                  onChange={(e) => updateValue(value.alternativeId, parseFloat(e.target.value) || 0)}
                  className="w-32 px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                <span className="text-sm text-gray-500 w-20">
                  → {normalizedResults.find(r => r.alternativeId === value.alternativeId)?.normalizedWeight.toFixed(3)}
                </span>
              </div>
            </div>
          ))}
        </div>

        {/* 정규화 결과 미리보기 */}
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h5 className="font-medium text-green-800 mb-3">정규화 결과 미리보기</h5>
          <div className="space-y-2">
            {normalizedResults
              .sort((a, b) => b.normalizedWeight - a.normalizedWeight)
              .map((result, index) => (
                <div key={result.alternativeId} className="flex justify-between items-center">
                  <span className="flex items-center">
                    <span className="text-sm font-medium w-6">#{index + 1}</span>
                    <span>{result.alternativeName}</span>
                  </span>
                  <span className="font-medium text-green-700">
                    {(result.normalizedWeight * 100).toFixed(1)}%
                  </span>
                </div>
              ))}
          </div>
        </div>

        {/* 완료 버튼 */}
        <div className="flex justify-end space-x-3">
          <button
            onClick={() => onComplete(values)}
            className="bg-green-500 text-white px-6 py-2 rounded hover:bg-green-600"
          >
            평가 완료
          </button>
        </div>
      </div>
    </Card>
  );
};

export default DirectInputEvaluation;
```

### 3. 판단 도우미 컴포넌트

```typescript
// frontend/src/components/evaluation/ConsistencyHelper.tsx
import React, { useState, useEffect } from 'react';
import { 
  calculateAHP,
  buildComparisonMatrix
} from '../../utils/ahpCalculator';

interface InconsistencyAdvice {
  i: number;
  j: number;
  currentValue: number;
  recommendedValue: number;
  errorMagnitude: number;
  rank: number;
}

const ConsistencyHelper: React.FC<{
  matrix: number[][];
  elements: Array<{id: string, name: string}>;
  onSuggestionApply: (i: number, j: number, value: number) => void;
  onClose: () => void;
}> = ({ matrix, elements, onSuggestionApply, onClose }) => {

  const [suggestions, setSuggestions] = useState<InconsistencyAdvice[]>([]);

  useEffect(() => {
    if (matrix.length > 0) {
      generateSuggestions();
    }
  }, [matrix]);

  const generateSuggestions = () => {
    try {
      const result = calculateAHP(matrix);
      const weights = result.priorities;
      
      // 일관 행렬 A^ 구성: a^_ij = w_i / w_j
      const consistentMatrix: number[][] = weights.map(wi => 
        weights.map(wj => wi / wj)
      );

      // 오차 계산: E_ij = |log(a_ij) - log(a^_ij)|
      const errors: Array<{i: number, j: number, error: number}> = [];
      
      for (let i = 0; i < matrix.length; i++) {
        for (let j = i + 1; j < matrix.length; j++) {  // 상삼각만
          const actualValue = matrix[i][j];
          const consistentValue = consistentMatrix[i][j];
          const error = Math.abs(Math.log(actualValue) - Math.log(consistentValue));
          errors.push({ i, j, error });
        }
      }

      // |E_ij| 상위 3개 선별
      const topErrors = errors
        .sort((a, b) => b.error - a.error)
        .slice(0, 3);

      const newSuggestions: InconsistencyAdvice[] = topErrors.map((item, index) => {
        const consistentValue = weights[item.i] / weights[item.j];
        const nearestSaatyValue = findNearestSaatyValue(consistentValue);
        
        return {
          i: item.i,
          j: item.j,
          currentValue: matrix[item.i][item.j],
          recommendedValue: nearestSaatyValue,
          errorMagnitude: item.error,
          rank: index + 1
        };
      });

      setSuggestions(newSuggestions);
    } catch (error) {
      console.error('Failed to generate suggestions:', error);
    }
  };

  const findNearestSaatyValue = (target: number): number => {
    const saatyValues = [1/9, 1/8, 1/7, 1/6, 1/5, 1/4, 1/3, 1/2, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    return saatyValues.reduce((prev, curr) => 
      Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev
    );
  };

  const formatSaatyValue = (value: number): string => {
    if (value === 1) return '1 (동등)';
    if (value > 1) return `${value} (좌측 우세)`;
    return `1/${Math.round(1/value)} (우측 우세)`;
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-96 overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-bold text-red-600">🚨 판단 도우미</h3>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700"
          >
            ✕
          </button>
        </div>

        <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded">
          <p className="text-yellow-800 text-sm">
            ⚠️ 일관성 비율이 0.1을 초과했습니다. 다음 제안을 검토하여 판단을 수정해보세요.
          </p>
        </div>

        <div className="space-y-3">
          {suggestions.map(suggestion => (
            <div key={`${suggestion.i}-${suggestion.j}`} className="border border-gray-200 rounded-lg p-4">
              <div className="flex justify-between items-start mb-3">
                <div>
                  <h5 className="font-medium text-red-600">제안 {suggestion.rank}</h5>
                  <p className="text-sm text-gray-600">
                    <strong>{elements[suggestion.i]?.name}</strong> vs <strong>{elements[suggestion.j]?.name}</strong>
                  </p>
                </div>
                <span className="text-xs bg-red-100 text-red-700 px-2 py-1 rounded">
                  오차: {suggestion.errorMagnitude.toFixed(3)}
                </span>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-3">
                <div className="bg-gray-50 p-3 rounded">
                  <div className="text-sm text-gray-600">현재 값</div>
                  <div className="font-medium">{formatSaatyValue(suggestion.currentValue)}</div>
                </div>
                <div className="bg-green-50 p-3 rounded">
                  <div className="text-sm text-green-600">권장 값</div>
                  <div className="font-medium text-green-700">
                    {formatSaatyValue(suggestion.recommendedValue)}
                  </div>
                </div>
              </div>

              <button
                onClick={() => onSuggestionApply(suggestion.i, suggestion.j, suggestion.recommendedValue)}
                className="w-full bg-green-500 text-white py-2 rounded hover:bg-green-600"
              >
                이 제안 적용
              </button>
            </div>
          ))}
        </div>

        <div className="mt-6 flex justify-end space-x-3">
          <button
            onClick={onClose}
            className="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600"
          >
            나중에 수정
          </button>
        </div>
      </div>
    </div>
  );
};

export default ConsistencyHelper;
```

## 📋 즉시 적용할 수정사항

### 1. PairwiseComparison.tsx 개선

```typescript
// 추가할 상태와 기능
const [consistencyRatio, setConsistencyRatio] = useState<number>(0);
const [showConsistencyHelper, setShowConsistencyHelper] = useState(false);

// 실시간 일관성 계산
useEffect(() => {
  if (pairs.length > 0 && getCompletedCount() === pairs.length) {
    try {
      const matrix = buildComparisonMatrix(elements!, comparisons);
      const result = calculateAHP(matrix);
      setConsistencyRatio(result.consistencyRatio);
      
      if (result.consistencyRatio > 0.1) {
        setShowConsistencyHelper(true);
      }
    } catch (error) {
      console.error('Failed to calculate consistency:', error);
    }
  }
}, [comparisons, pairs]);

// CR > 0.1 시 판단 도우미 표시
{showConsistencyHelper && (
  <ConsistencyHelper
    matrix={currentMatrix}
    elements={elements}
    onSuggestionApply={(i, j, value) => {
      // 제안 적용 로직
      applySuggestion(i, j, value);
      setShowConsistencyHelper(false);
    }}
    onClose={() => setShowConsistencyHelper(false)}
  />
)}
```

### 2. ModelBuilder.tsx에 평가자 배정 추가

```typescript
// ModelBuilder.tsx에 추가
import EvaluatorAssignment from '../admin/EvaluatorAssignment';

// 새 탭 추가
const [activeModelTab, setActiveModelTab] = useState<'criteria' | 'alternatives' | 'evaluators'>('criteria');

// 탭 네비게이션 UI
<div className="flex space-x-4 border-b border-gray-200 mb-6">
  <button
    onClick={() => setActiveModelTab('criteria')}
    className={`pb-2 px-1 ${activeModelTab === 'criteria' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-500'}`}
  >
    평가 기준
  </button>
  <button
    onClick={() => setActiveModelTab('alternatives')}
    className={`pb-2 px-1 ${activeModelTab === 'alternatives' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-500'}`}
  >
    대안
  </button>
  <button
    onClick={() => setActiveModelTab('evaluators')}
    className={`pb-2 px-1 ${activeModelTab === 'evaluators' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-500'}`}
  >
    평가자 배정
  </button>
</div>

// 조건부 렌더링
{activeModelTab === 'evaluators' && (
  <EvaluatorAssignment projectId={projectId} />
)}
```

이러한 개선사항들을 통해 요구사항의 화면 설계를 90% 이상 구현할 수 있습니다.